# Circuit Design Document for zkNFT Ownership Proof

## Scope

This document covers the circuit’s overall design, key components, constraints, and the interaction between off-chain proof generation and on-chain verification.

## Circuit Overview

### Objectives

- **Privacy**: Prove NFT ownership without exposing any private data.
- **Integrity**: Ensure that the proof is valid and corresponds to the NFT’s data stored on-chain.
- **Efficiency**: Design a circuit that is SNARK-friendly (using efficient hash functions and constraints) to keep gas and computation costs minimal.

### High-Level Flow

1. **Input Collection**:
   - **Private Input (Witness)**: A secret value (e.g., a private key or a unique nonce) that only the owner knows.
   - **Public Input**: A hash or commitment associated with the NFT ownership stored on-chain.
2. **Hash Computation**:
   - Use a SNARK-friendly hash function - Poseidon - to compute a hash from the private input.
3. **Constraint Verification**:
   - The circuit checks that the computed hash matches the public input.
4. **Proof Generation**:
   - If the constraint holds, a valid zkSNARK proof is generated to attest that the user knows the secret associated with the NFT without revealing it.

## Detailed Circuit Components

### Inputs

- **Private (Witness) Input**:
  - Represents the secret that proves NFT ownership (e.g., a cryptographic key or nonce).
  - Kept hidden from the public.
- **Public Input**:
  - A pre-computed hash value or commitment linked to the NFT stored on the blockchain.
  - Used to verify that the private input is correct without revealing the secret itself.

### Hash Module

- **Purpose**:
  - Compute a cryptographic hash of the private input.
- **Design Choice**:
  - SNARK-Friendly Hash Function option, Poseidon, is designed for efficient verification in zkSNARK circuits.
- **Operation**:
  - The module takes the private input and outputs a hash that can be compared with the public input.

### Constraint Module

- **Core Constraint**:
  - The computed hash must equal the public input.
- **Verification**:
  - This equality check forms the primary arithmetic constraint within the circuit.
  - The circuit outputs a “true” result only if the constraint holds, ensuring the proof’s validity.

### Circuit Architecture Diagram (Conceptual)

```
+--------------------+     +-------------------+     +----------------------+
| Private Input (w)  | --> |    Hash Module    | --> | Comparison Constraint|
|  (secret value)    |     | (e.g., Poseidon)  |     | (computed hash ==    |
+--------------------+     +-------------------+     |  public input)       |
                                                                        +----------------------+
                                                                                  |
                                                                                  v
                                                                        +------------------------+
                                                                        |   Valid Proof Output   |
                                                                        | (if constraint holds)  |
                                                                        +------------------------+
```

## Implementation Details

### Tools and Libraries

- **Proof Generation**:
  - Tools like circom and snarkjs to design, compile, and test the circuit.
- **Smart Contract Integration**:
  - The proof generated by the circuit will be verified on-chain by an ERC-721 smart contract.
- **Development Environment**:
  - Use Hardhat for smart contract development and testing.

### Integration with the Overall System

- **Off-Chain Component**:
  - The circuit runs off-chain during the proof generation phase.
  - The resulting proof is then submitted to the smart contract for verification.
- **On-Chain Component**:
  - The ERC-721 smart contract includes a verification function that accepts the proof and the public input.
  - Only if the proof is valid (i.e., the computed hash equals the public input) does the contract perform state changes (e.g., NFT transfer or validation).

## Security and Optimization Considerations

- **Zero-Knowledge Property**:
  - The circuit ensures that no private data is leaked during the proof process.
- **Circuit Efficiency**:
  - Optimize the number of constraints to reduce gas costs and improve verification times.
- **Robustness**:
  - Ensure that the circuit is resistant to common attacks, such as invalid input manipulations or attempts to forge proofs.

## Future Enhancements

- **Multi-Signature Proofs**:
  - Extend the circuit to support proofs that require multiple private inputs (e.g., joint ownership).
- **Additional Constraints**:
  - Incorporate other verification logic that may be required by future NFT standards or project-specific features.
- **Optimized Hash Functions**:
  - Evaluate newer or more efficient SNARK-friendly hash functions as the field evolves.
